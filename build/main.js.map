{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport axios, { type AxiosRequestConfig } from 'axios';\nimport schedule from 'node-schedule';\n\nclass Hydrop extends utils.Adapter {\n    private apiBaseUrl: string = 'https://api.hydrop-systems.com';\n    private pollInterval: number = 5; // in minutes\n    private interval: ioBroker.Interval | undefined;\n    private lastMeterReading: number | null = null;\n    private meterReading: number = 0;\n    private lastTimestampUnix: number | null = null;\n    private consumption: number = 0;\n    private flowRate: number = 0;\n    private timestampUnix: number = 0;\n    private apiKey: string = '';\n    private meterName: string = '';\n    private historyDays: number = 7;\n    private dailyConsumption: number = 0;\n    private newDailyConsumption: number = 0;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'hydrop',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    private async onReady(): Promise<void> {\n        this.apiKey = this.config.apiKey || '';\n        this.meterName = this.config.meterName || '';\n        this.historyDays = this.config.historyDays || 7;\n\n        // Initialize states\n        await this.createdHistoryStates();\n        await this.delHistoryStates();\n\n        await this.schedulePoll();\n        this.log.info('Hydrop adapter started');\n\n        schedule.scheduleJob('dayHistory', '0 0 0 * * *', async () => await this.setDayHistory());\n    }\n\n    private onUnload(callback: () => void): void {\n        try {\n            this.clearInterval(this.interval);\n            schedule.cancelJob('dayHistory');\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    private async schedulePoll(): Promise<void> {\n        if (this.apiKey === '' || this.meterName === '') {\n            this.log.error('API Key or Meter Name not configured. Please check the adapter settings.');\n            return;\n        }\n\n        await this.poll();\n        this.interval = this.setInterval(() => this.poll(), this.pollInterval * 60_000);\n    }\n\n    private async poll(): Promise<void> {\n        const available: boolean = await this.validateURL();\n        if (!available) {\n            this.log.error('Hydrop API not available, skipping poll cycle');\n            return;\n        }\n\n        try {\n            const hydropRequest = await axios({\n                method: 'get',\n                url: `${this.apiBaseUrl}/sensors/ID/${this.meterName}/newest`,\n                headers: {\n                    apikey: this.apiKey,\n                },\n                timeout: 10000,\n                responseType: 'json',\n            });\n\n            if (hydropRequest?.data?.sensors?.[0]?.records?.[0]) {\n                const record = hydropRequest.data.sensors[0].records[0];\n\n                this.meterReading = record.meterValue;\n                await this.setState('data.meterReading', record.meterValue, true);\n\n                this.timestampUnix = record.timestamp;\n                await this.setState('data.measurementTime', new Date(this.timestampUnix * 1000).toISOString(), true);\n\n                this.log.debug(\n                    `Meter Value: ${record.meterValue} m\u00B3 at ${new Date(this.timestampUnix * 1000).toISOString()}`,\n                );\n\n                await this.calcData();\n            } else {\n                this.log.warn('No valid data received from Hydrop API');\n            }\n        } catch (error) {\n            this.log.error(`Polling error: ${error.message}`);\n        }\n    }\n\n    private async calcData(): Promise<void> {\n        // Calculate Consumption\n        if (this.lastMeterReading !== null) {\n            this.consumption = this.meterReading - this.lastMeterReading;\n\n            if (this.consumption > 0) {\n                this.newDailyConsumption = this.dailyConsumption + this.consumption;\n\n                await this.setState('data.dailyConsumption', this.newDailyConsumption, true);\n                this.dailyConsumption = this.newDailyConsumption;\n\n                this.log.debug(\n                    `Calculated Consumption: ${this.consumption} m\u00B3, Daily Consumption: ${this.newDailyConsumption} m\u00B3`,\n                );\n            } else {\n                this.log.debug('No consumption detected (meter value did not increase)');\n            }\n        } else {\n            this.log.debug('Old meter reading not available, skipping consumption calculation');\n        }\n\n        // Calculate Flow Rate (L/min)\n        if (!this.lastMeterReading || !this.lastTimestampUnix || this.meterReading === null || !this.timestampUnix) {\n            this.log.debug('Old meter reading or timestamp not available, skipping flow rate calculation');\n            return;\n        }\n\n        this.flowRate =\n            ((this.meterReading - Number(this.lastMeterReading)) * 1000) /\n            ((this.timestampUnix - Number(this.lastTimestampUnix)) / 60);\n\n        await this.setState('data.averageFlowRate', this.flowRate, true);\n        this.log.debug(`Calculated Flow Rate: ${this.flowRate} L/min`);\n\n        this.lastMeterReading = this.meterReading;\n        this.lastTimestampUnix = this.timestampUnix;\n    }\n\n    private async setDayHistory(): Promise<void> {\n        const historyDays = this.historyDays - 1;\n\n        for (let c = historyDays; c >= 0; c--) {\n            try {\n                let state;\n\n                if (c == 0) {\n                    state = await this.getStateAsync('data.dailyConsumption');\n                } else {\n                    state = await this.getStateAsync(`history.consumption_${c}_days_ago`);\n                }\n\n                if (state && state.val !== undefined) {\n                    const _c = c + 1;\n                    await this.setState(`history.consumption_${_c}_days_ago`, state.val, true);\n                    this.log.debug(`history consumption ${_c} days ago: ${state.val} m\u00B3`);\n                }\n            } catch (err) {\n                this.log.warn(err);\n            }\n        }\n        await this.setState('data.dailyConsumption', 0, true);\n    }\n\n    private async delHistoryStates(): Promise<void> {\n        const _historyStates = await this.getForeignObjectsAsync(`${this.namespace}.history.*`);\n\n        for (const i in _historyStates) {\n            const historyID = _historyStates[i]._id;\n            const historyName: string = historyID.split('.').pop() ?? '';\n            const parts = historyName.split('_');\n            const parsed = parseInt(parts[1], 10);\n            const historyNumber: number | undefined = !isNaN(parsed) ? parsed : undefined;\n\n            if (historyNumber !== undefined && historyNumber > this.historyDays) {\n                try {\n                    await this.delObjectAsync(historyID);\n                    this.log.debug(`Delete old History State \"${historyName}\"`);\n                } catch (e) {\n                    this.log.warn(`Cannot Delete old History State \"${historyName}\"`);\n                }\n            }\n        }\n    }\n\n    private async createdHistoryStates(): Promise<void> {\n        for (let c = 0; c < this.historyDays; c++) {\n            const _historyDays = c + 1;\n\n            await this.setObjectNotExistsAsync(`history.consumption_${_historyDays}_days_ago`, {\n                type: 'state',\n                common: {\n                    role: 'value.fill',\n                    name: `Daily consumption ${_historyDays} days ago`,\n                    type: 'number',\n                    read: true,\n                    write: false,\n                    unit: 'm\u00B3',\n                    def: 0,\n                },\n                native: {},\n            });\n        }\n    }\n\n    private async validateURL(): Promise<boolean> {\n        try {\n            const response = await axios.get(this.apiBaseUrl, {\n                timeout: 10000,\n                validateStatus: () => true,\n            });\n            if (response && response.status) {\n                this.log.debug(`Hydrop API is available ... Status: ${response.status}`);\n                await this.setState('info.connection', true, true);\n                return true;\n            } else {\n                this.log.warn('Hydrop API did not return a valid response');\n                await this.setState('info.connection', false, true);\n                return false;\n            }\n        } catch (err) {\n            this.log.error(`Hydrop API is not available: ${err}`);\n            await this.setState('info.connection', false, true);\n            return false;\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Hydrop(options);\n} else {\n    // otherwise start the instance directly\n    (() => new Hydrop())();\n}\n"],
  "mappings": "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",
  "names": ["schedule", "axios"]
}
